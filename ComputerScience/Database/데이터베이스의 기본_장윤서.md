# 📄 데이터베이스의 기본 _ 2023.01.12
* 데이터베이스(DB, Database)는 **일정한 규칙**을 통해 구조화되어 저장되는 데이터의 모음.
* DB를 제어, 관리하는 통합 시스템을 DBMS, DataBase Management System이라고 하며 DB안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리언어 Query Language를 통해 삽입, 삭제, 수정, 조회(CRUD) 등을 수행할 수 있다.
* 실시간 접근 및 동시 공유가 가능하다.

![](http://terms.tta.or.kr/upload/image/terms2021/38_dbms.png)

* 예를 들어, MySQL이라는 DBMS가 있고 그 위의 응용프로그램에 속하는 Node.js나 php에서 DB안에 있는 데이터에 접근할 수 있다.

<br>


## 1️⃣ Entity 엔티티
* Entity : 여러 개의 속성을 지닌 명사     
  ex ) 회원이라는 entity - 이름 / 아이디 / 주소  / 전화번호 등의 속성을 가진다.     
       더 많은 속성을 가질 수도 있지만, **서비스의 요구사항**에 따라 속성은 달라질 수 있다.
* 약한 엔터티와 강한 엔터티 : A 엔터티가 혼자 존재하지 못하고 B 엔터티에 종속적이면 A는 약한 엔터티, B는 강한 엔터티이다.

<br>

## 2️⃣ Relation 릴레이션 
* relation : DB에서 정보를 구분하여 저장하는 기본 단위
* 엔터티 하나를 릴레이션 하나에 !
* `관계형 데이터베이스 RDBMS`에서는 `테이블 Table`, `레코드 - 테이블 - 데이터베이스` 구조
* `NoSQL 데이터베이스`에서는 `컬렉션 Collection`, `도큐먼트 - 컬렉션 - 데이터베이스` 구조     
  여기서 NoSQL이란 > 무엇의 약자인지는 사람에 따라 No SQL, Not Only SQL, Non-Relational Operational Database SQL 등으로 엇갈리는 의견이 있다. 현재 Not Only SQL로 풀어 설명하는 것이 다수를 차지하고 있다. 이는 RDBMS가 갖고있는 특성 뿐만 아니라 다른 특성도 지원한다는 뜻으로 해석할 수 있다. (나중에 더 공부해보기 !)

<br>

## 3️⃣ Attribute 속성
* 위의 엔터티 설명할 때 나온 속성! 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
* 서비스의 요구사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 된다.

<br>

## 4️⃣ Domain 도메인
* 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
* ex ) 회원의 `나이` 속성이 가질 수 있는 값 = {1,2,3,4, ... , 100, 101, ...}
* ex ) 회원의 `성별` 속성이 가질 수 있는 값 = {남성, 여성}
* `회원`이라는 `릴레이션`에 `이름, 아이디, 회원번호, 성별, 나이` 등의 `속성`을 가질 수 있고, `나이` 속성은 `{남성, 여성}`이라는 `도메인`을 가질 수 있다.

<br>

## 5️⃣ 필드와 레코드

| id  | account_name  |        email        |  address  |  gender  |     created_at      |
|:---:|:-------------:|:-------------------:|:---------:|:--------:|:-------------------:|
|  1  |      장윤서      | younseojj@gmail.com |    서울     |    여성    | 2022-12-23-23:12:38 |
|2|정성우| anfrosus@naver.com  | 서울| 남성| 2023-01-12-01:43:49 |

* 회원이라는 entity는 `테이블`로 이름, 이메일, 주소, 성별 등의 `속성`을 가지고 있으며 account_name, email, address, gender 등의 `필드`를 가진다. 
* 테이블에 쌓이는 한 줄 한 줄의 데이터 = 레코드 = 튜플
* 레코드의 단위 = 행(row)     

---

### ▶️  '회원'이라는 ENTITY를 정의하고, 이를 기반으로 TABLE을 만들어보자!
* 어떤 속성이 올 수 있지 ? -> 이름, 이메일, 주소, 성별, 가입 날짜 등
* 이 엔터티를 데이터베이스에 넣어서 테이블로 만들려면 ?      
  속성 마다 맞는 `타입`을 지정해주어야 하겠구나!
* `타입`은 DB마다 조금씩 다르다. 오늘은 MySQL을 기준으로!
  * 회원 id = INT
  * 회원 이름 = VARCHAR(255)
  * 회원 이메일 = VARCHAR(255)
  * 주소 = VARCHAR(255)
  * 성별 = VARCHAR(255)
  * 생성날짜 = DATETIME
* 보통 한글로 속성이름을 사용하지 않는다. 회원 이름은 account_name, 성별은 gender 등으로 영어이름에 매핑해서 사용한다.
* 위의 회원 테이블을 MySQL로 구현하려면 다음과 같은 코드를 작성해야 한다.
 ```SQL
CREATE TABLE ACCOUNT(
    ID INT NOT NULL AUTO_INCREMENT,
    ACCOUNT_NAME VARCHAR(255) NOT NULL,
    EMAIL VARCHAR(255) NOT NULL,
    ADDRESS VARCHAR(255),
    GENDER VARCHAR(255),
    CREATED_AT DATE,
    PRIMARY KEY (ID)
);
```
`NOT NULL` = NULL이 올 수 없다. 값이 항상 필요하다!

---

###  ▶️ 필드 타입은 뭐가 있을까?
* DBMS마다 타입은 다르다. 근데 거의 비슷하다!
* MySQL 기준으로 필드 타입은 어떻게 되는지 알아보자.
#### 🔘 숫자타입
> * TINYINT, SMALLINT, MEDIUMINT, INT,BIGINT 등      
#### 🔘 날짜타입
> * DATE, DATETIME, TIMESTAMP 등   
> * `DATE` : 날짜는 있지만 시간은 필요하지 않는 경우, 1000-01-01 ~ 9999-12-31 범위 지원. 3바이트    
> *  `DATETIME` : 날짜 및 시간 부분을 모두 포함하는 값, 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 범위. 8바이트    
> * `TIMESTAMP` : 날짜 및 시간 부분 모두 포함, 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 까지 지원. 4바이트
#### 🔘 문자타입
> * CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 등    
> * `CHAR와 VARCHAR` : ()안에 몇 자 까지 입력할 건지 정할 수 있다. CHAR같은 경우, CHAR(30)이면 30글자까지 작성 가능하다.   
> * `CHAR`는 테이블을 생성할 때 선언한 그 길이로 고정되며 길이는 0~255 사이의 값을 가질 수 있다. 레코드를 저장할 때 무조건 그 길이로 고정되어 저장된다.    
> * `VARCHAR` 같은 경우는 가변 길이 문자열로, 0~65,535 사이의 값을 가질 수 있다. 입력된 데이터에 따라 용량을 가변시켜 저장한다.    
> * VARCHAR(60000)으로 지정해두어도 `장윤서`를 입력하면 `장윤서에 대한 바이트` + `길이 기록용 1바이트`로 저장하게 된다.
> * `TEXT와 BLOB` : 큰 데이터를 저장할 때 / TEXT - 큰 문자열 저장용(게시판의 본문 등) / BLOB - 이미지, 동영상 등 큰 데이터 저장용, 보통은 AWS S3 사용해서 서버에 올리고 파일에 관한 경로를 VARCHAR로 받아서 저장하는 경우가 많다. (우리 프로젝트 했던 것 처럼!)
> * `ENUM과 SET` : 문자열을 열거한 타입

<br>

## 6️⃣  관계
### ▶️ 1:1 관계 (일 대 일 관계)
 * 유저 당 유저 이메일 1개가 존재 할 때 굳~~이 테이블을 나누면 1:1 관계가 된다.
### ▶️ 1:N 관계 (일 대 다 관계)
*  한 유저가 여러 개의 상품을 장바구니에 담을 때!
*  프로젝트에서 포스트 - 댓글 사이의 관계 (하나의 post에는 여러 개의 댓글이 달릴 수 있다.)
*  상품을 담지 않을 수도, 댓글이 달리지 않을 수도 있기에 0도 포함되는 화살표로 표현이 된다.
### ▶️ N:M 관계 (다 대 다 관계)
* 프로젝트에서 유저 - 채팅방 사이의 관계 
*  하나의 채팅방에 여러 명의 유저가 포함되고, 유저도 여러 개의 채팅방을 가질 수 있다. 
* 이런 경우에 N:M 다대다 관계가 된다. 
* 다대다 관계의 경우, 테이블 두 개를 직접적으로 연결해서 구축하지는 않고, 1:N, 1:M 관계를 갖는 테이블 두 개로 나누어 구현한다.

<br>

## 7️⃣ 키
* 테이블 간의 관계를 좀 더 명확하게 하고, 테이블 자체의 인덱스 설정을 위해 필요하다.
* `기본키`, `외래키`, `슈퍼키`, `대체키`가 있다.     
<br>

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb61dOa%2FbtqGgjeFbnE%2F3PLqMbKhtALl89KtYX4Bt1%2Fimg.png)

* `기본키` : Primary Key, PK라고 많이 부른다. 유일성과 최소성을 만족하는 키이다.     
   기본키는 자연키, 인조키 중에 골라서 사용한다.     
   자연키 : 회원 테이블에서 이름, 성별, 나이는 중복될 수 있다. 이메일은 중복될 수 없다. 따라서 자연키 중에서 기본키를 골라야 한다면, 이메일이 될 수있다. 하지만 자연키는 특성상 언제든 변할 수 있는 속성을 가지고 있다.     
   인조키 : 회원 테이블에서 id로 부여한 1, 2, 3 .. 순서대로 증가하는 숫자값. 인위적으로 id값을 부여하여 식별할 수 있게 한다. 이렇게 인위적으로 생성한 값을 인조키라고 한다. 자연키와는 대조적으로 변하지 않는 값이다.
* 보통은 인조키로 기본키를 많이 사용한다!
* `외래키` : Foreign Key, FK라고 부른다. 다른 테이블의 PK를 참조하는 값이다.     
   우리 프로젝트에서, 댓글을 작성할 때 프론트엔드에서 post id 값을 넘겨줌으로써 db에 저장할 때 post id - comment id 이런식으로 매핑하여 저장했다.     
   외래 키는 중복될 수 있다. (포스트 아이디 1에 여러개의 댓글이 달리는 경우)
* `후보키` : candidate key, 기본키가 될 수 있는 후보들
* `대체키` : alternative key, 후보키가 두 개 이상일 경우 어느 하나를 PK로 지정하고 남은 후보키
* `슈퍼키` : super key, 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키