# 데이터 베이스의 종류

## 관계형 데이터베이스 🌼
* 관계형 데이터베이스(RDBME)는 행과 열을 가지는 표 형식의 데이터를 저장하는 형태의 DB
* SQL 언어를 써서 조작한다.

### MySQL 
* 대부분의 운영체제와 호환되며, 현재 가장 많이 사용하는 DB
* C, C++로 만들어졌으며 MyISAM 인덱스 압축기술, B-tree 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스 제공
* 대용량 DB를 위해 설계되어 있고 롤백, 커밋, 이중 암호 지원 보안 등의 기능 제공

### PostgreSQL 
* VACUUM : 디스크 조각이 차지하는 영역을 회수할 수 있는 장치
* 최대 테이블의 크기 : 32TB
* SQL 뿐만 아닌 JSON을 이용하여 데이터 접근 가능
* 지정 시간에 복구하는 기능, 로깅, 접근제어, 중첩된 트랜젝션, 백업 등

## NoSQL 데이터베이스 🌼
* NoSQL(Not Only SQL)
* SQL을 사용하지 않는 데이터베이스 
* MongoDB, Redis

### MongoDB 
* JSON을 통해 데이터 접근 가능
* Binary JSON 형태(BSON)로 데이터 저장
* 와이어드타이거 엔진이 기본 스토리지 엔진
* 키-값 데이터 모델, 도큐먼트 기반
* 도큐먼트를 생성할 때 마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 ObjectID가 생성됨.

### Redis 
* 인메모리 데이터베이스
* 키-벨류 데이터 모델 기반의 DB
* 기본 데이터 타입 : 문자열(String), 최대 512MB까지 저장
* set, hash 지원
* pub/sub 기능을 통한 채팅

---

# 인덱스
## 인덱스의 필요성 🌼 
* 데이터를 빠르게 찾을 수 있는 하나의 장치
* 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.

## B-트리 🌼

[참고 벨로그](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)

![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fb7df8287-2524-4ec0-ad03-b969a8830c8e%2FB%ED%8A%B8%EB%A6%AC%20%EA%B2%80%EC%83%89%201.png)
![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fe20bdef7-e106-4c89-9560-d7f57154dce1%2FB%ED%8A%B8%EB%A6%AC%20%EA%B2%80%EC%83%89%202.png)

* 인덱스는 보통 B-tree라는 자료구조로 이루어져 있다.
* 루트노드 - (브랜치노드) - 리프노드

### 인덱스가 효율적인 이유
* 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조
* 대수확장성
> 대수확장성이란, 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미한다. 
> 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 항목수는 4배씩 증가한다.

| 트리깊이 | 인덱스 항목 수  |
|:----:|:---------:|
|  3   |    64     |
|  4   |    256    |
|  5   |   1,024   |
|  6   |   4,096   |
|  7   |  16,384   |
|  8   |  65,536   |
|  9   |  262,144  |
|  10  | 1,048,576 |

* 트리 깊이 10개로 100만 개의 레코드를 검색할 수 있다.

[B트리, B+트리, B*트리 개념 정리](https://velog.io/@seanlion/btree)

## 인덱스 최적화 기법 🌼 
<MongoDB 기준으로 설명함>

### 1. 인덱스는 비용이다.
* 인덱스는 두 번 탐색하도록 강요 - 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 읽기 비용이 든다.
* 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.
* B-tree의 높이를 균형있게 조절하는 것도 비용이 들고, 데이터를 분산시키는 비용도 든다.
* 따라서 모든 필드에 인덱스를 설정하는 것은 효율적이지 않다.
* 컬렉션에서 가져와야 하는 데이터의 양이 많을 수록 인덱스를 설정하는 것은 비효율적이다.

### 2. 항상 테스팅하라.
* 최적화 기법은 서비스마다 다르기 때문에 객체의 깊이, 테이블의 양에 따라 항상 테스팅하는 것이 중요하다.
```sql
<MySQL 테스팅 코드>
    
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

### 3. 복합인덱스는 같음 - 정렬 - 다중 값 - 카디널리티 순이다. 
* 1. ==, equal 쿼리가 있으면 제일 먼저 인덱스로 설정
* 2. 정렬에 쓰는 필드는 그 다음으로 설정
* 3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 "이거나" 등 많은 값을 출력해야 하는 쿼리의 필드라면 나중에 인덱스 설정
* 4. 카디널리티 = 유니크한 값의 정도 / 카디널리티가 높은 순으로 인덱스를 생성해야 함 - ex ) age and email 


