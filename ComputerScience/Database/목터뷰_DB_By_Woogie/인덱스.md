# 인덱스란?

데이터베이스의 index는 책의 색인과 같다.
데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다. 
Full Scan과 비교했을때 처리 속도가 뛰어나다.

<br><br>


## [ 인덱스(index)의 장점과 단점 ]
<br>

- **장점**
    
    **(1)** 테이블을 **조회하는 속도**와 그에 따른 **성능을 향상**시킬 수 있다.
    
    **(2)** 전반적인 시스템의 **부하를 줄일 수 있다.**
    
- **단점**
    
    **(1)** 인덱스를 잘못 사용할 경우 **오히려 성능이 저하**되는 **역효과**가 발생할 수 있다.
    
    **(2)** 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 **저장공간이 필요**하다. (인덱스 영역을 전체 테이블 영역의 30 ~ 50%까지 잡아 놓을 만큼 저장 공간이 꽤나 많이 필요하다.)
    
    **(3)** 인덱스를 관리하기 위해 **추가 작업**이 필요하다.

<br><br>
    
## [ 인덱스(index)를 사용하면 좋은 경우 ]
<br>


**(1) 규모가 작지 않은 테이블**

**(2) INSERT / UPDATE / DELETE가 자주 발생하지 않는 컬럼**

**(3) 혹은 JOIN / WHERE / ORDER BY에 자주 사용되는 컬럼**

**(4) 혹은 데이터의 중복도가 낮은 컬럼**

<br><br>

## [ 대표적 케이스 : 해시 테이블과 B+Tree ]

<br>

### [ 해시 테이블(Hash Table) ]

<br>

- 빠른 데이터 검색이 필요할 때 유용

- 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

- 해시 테이블 기반의 DB 인덱스는 (데이터=컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현하였다. 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.

- 하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문

<br>

### [ B+Tree ]

<br>

- B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조

- 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 BTree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화

- Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점도 있다

- 비록 B+Tree는 O(log2n) 의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.

- 리프노드들은 LinkedList로 연결되어 있다.

- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

<br><br>

## 복합인덱스
<br>

- 복합인덱스는 2개이상의 컬럼으로 구성된 인덱스

- 복합인덱스는 단일인덱스를 능가하는 성능을 낼수있으며, 여러개의 인덱스를 대신할수도있다

- 인덱스가 조회속도개선에는 도움이되지만, 입력/수정/삭제에서는 성능이 감수한다.

- 1번필드를 인덱스로 구성하면 1번필드는 인덱스에서 찾을수있지만 2번필드는 테이블에 접근해야만 
확인할수있다. 반면 복합인덱스로 1번필드 2번필드를 구성하면 모두 인덱스안에서 처리가능

- 인덱스에 없는 컬럼을 확인하기위해서는 테이블접근이 필수다, 적절한 컬럼수로 복합인덱스를 구성하여 성능향상을 고려해야한다.



